#include <iostream>
#include <fstream>
#include <vector>
#include <string>

using namespace std;

/*
   Operations:
   Move forward in the same line: 1
   Move backward in the same line: 2
   Move to the beginning of another line: 3
   Move to the end of another line: 4
 */

 struct openvec {
   int fscore;
   int gscore;
   int hscore;
   int id;
   int comefrom;
   vector <string> grid;
 };

int heuristic(vector <string> init, vector <string> goal, int lane_number, int locations, string car){
        //Here we introduce the initial and goal position and calculate the heuristic (minimum cost from init to goal)
        int h;
        int init_lane;
        int init_column;
        int goal_lane;
        int goal_column;

        for (int i = 0; i < lane_number; i++) {
                for (int j = 0; j < locations; j++) {
                        if (init[i*locations+j]==car) {
                                init_lane=i;
                                init_column=j;
                                break;
                        }
                }
        }
        for (int i = 0; i < lane_number; i++) {
                for (int j = 0; j < locations; j++) {
                        if (goal[i*locations+j]==car) {
                                goal_lane=i;
                                goal_column=j;
                                break;
                        }
                }
        }

        h = abs(init_lane-goal_lane)+abs(init_column-goal_column);
        return h;
}

//This function calculates the movement cost for each non-blocked car
int cost(int lane_number, int loc, int initial_lane_number, int initial_loc, int locations){
        if(lane_number==initial_lane_number) {
                if(loc>initial_loc) {
                        return 1;
                }
                else if(loc<initial_loc){
                        return 2;
                }
        }
        else{
                if(loc==0) {
                        return 3;
                }
                else if(loc==locations) {
                        return 4;
                }
        }
        return 5;
}


void astar(vector <string> init_parking_mat, vector <string> goal_parking_mat, int lane_number, int locations){

        //struct vector <<closedvec> > closed_set;
        vector <openvec> open_set;
        open_set.push_back(openvec());
        open_set[0].grid = init_parking_mat;
        open_set[0].id = 0;
        int minimum = 0; //Minimum fscore found
        int hscore = 0; //Heuristic of the node
        int id_counter = 0; //Number of ids generated by the algorithm

        for (int i = 0; i < lane_number; i++) {
          for (int j = 0; j < locations; j++) {
            hscore += heuristic(init_parking_mat, goal_parking_mat, lane_number, locations, init_parking_mat[i*locations+j]);
          }
        }

        open_set[0].hscore = hscore;
        open_set[0].gscore = 0;
        open_set[0].fscore = open_set[0].hscore + open_set[0].gscore;

        cout << open_set[0].fscore << endl;


         while(open_set.size()!=0){
           struct openvec current_vec;
           //Here we look in the open_set list to find the grid with minimum fcost
           for (int i = 0; i < open_set.size(); i++) {
             if(open_set.size()==1){
               //If only the origin is open, we automatically asign it to current_vec
               if(open_set[i].id==0){
                 current_vec.id = i;
                 current_vec.fscore = open_set[i].fscore;
                 minimum = current_vec.fscore;
               }
             }
             if(open_set[i].fscore<minimum){
               current_vec.id = i;
               current_vec.fscore = open_set[i].fscore;
               minimum = current_vec.fscore;
             }
           }
           //Now we have the node with minimum cost
           vector <openvec> decendents;

           cost(current_vec);

         }
}

int main(int argc, char const *argv[]) {

        int counter = 0;
        vector<string> initialcars;
        string aux;

        //This part gets all strings from the initial state file
        ifstream initialfile(argv[1]);
        while (!initialfile.eof()) {
                initialfile >> aux;
                initialcars.push_back(aux);
        }
        initialfile.close();

        //Here we erase the last element of the vector, repeated due to the reading algorithm
        initialcars.pop_back();

        int lane_number = stoi(initialcars[0]);
        int locations = stoi(initialcars[1]);

        initialcars.erase(initialcars.begin());
        initialcars.erase(initialcars.begin());

        vector <string> init_parking_mat;

        for (int i = 0; i < lane_number; i++) {
                for (int j = 0; j < locations; j++) {
                        init_parking_mat.push_back(initialcars[0]);
                        initialcars.erase(initialcars.begin());
                }
        }

        //First check print
        for (int i = 0; i < lane_number; i++) {
                for (int j = 0; j < locations; j++) {
                        cout << init_parking_mat[i*locations+j] << " ";
                }
                cout << endl;
        }

        //Here, we get the data from the goal file

        vector<string> goalcars;

        ifstream goalfile(argv[2]);
        while (!goalfile.eof()) {
                goalfile >> aux;
                goalcars.push_back(aux);
        }
        goalfile.close();

        //Here we erase the last element of the vector, repeated due to the reading algorithm
        goalcars.pop_back();

        lane_number = stoi(goalcars[0]);
        locations = stoi(goalcars[1]);

        goalcars.erase(goalcars.begin());
        goalcars.erase(goalcars.begin());

        vector<string> goal_parking_mat;

        for (int i = 0; i < lane_number; i++) {
                for (int j = 0; j < locations; j++) {
                        goal_parking_mat.push_back(goalcars[0]);
                        goalcars.erase(goalcars.begin());
                }
        }

        //Second check print
        cout << endl;
        for (int i = 0; i < lane_number; i++) {
                for (int j = 0; j < locations; j++) {
                        cout << goal_parking_mat[i*locations+j] << " ";
                }
                cout << endl;
        }

        for (int i = 0; i < lane_number; i++) {
                for (int j = 0; j < locations; j++) {
                        if(init_parking_mat[i*locations+j]=="__") {
                        }
                        else{
                                counter++;
                        }
                }
        }

        if (counter==(lane_number*locations)) {
                cout << "Configuration unfeasible. No free slots." << endl;
                return 0;
        }

        astar(init_parking_mat, goal_parking_mat, lane_number, locations);

        // astar_search( init_parking_mat, goal_parking_mat, lane_number, locations);

        return 0;
}
