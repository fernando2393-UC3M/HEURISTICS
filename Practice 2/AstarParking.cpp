#include <iostream>
#include <fstream>
#include <vector>
#include <string>
#include <chrono>

using namespace std;
using namespace std::chrono;

using clk = high_resolution_clock;

 struct openvec {
   int fscore;
   int gscore;
   int hscore;
   int id;
   vector<string> grid;
   int parent_node;
   bool parent;
 };

int heuristic(vector <string> init, vector <string> goal, int lane_number, int locations, string car){
        //Here we introduce the initial and goal position and calculate the heuristic (minimum cost from init to goal)
        int h;
        int init_lane;
        int init_column;
        int goal_lane;
        int goal_column;

        for (int i = 0; i < lane_number; i++) {
                for (int j = 0; j < locations; j++) {
                        if (init[i*locations+j]==car) {
                                init_lane=i;
                                init_column=j;
                        }
                }
        }
        for (int i = 0; i < lane_number; i++) {
                for (int j = 0; j < locations; j++) {
                        if (goal[i*locations+j]==car) {
                                goal_lane=i;
                                goal_column=j;
                        }
                }
        }

        h = abs(init_lane-goal_lane)+abs(init_column-goal_column);
        return h;
}

//This function calculates the movement cost for each non-blocked car
int cost(vector <string> parking, int lane_number, int loc, int initial_lane_number, int initial_loc, int locations){
  int checker = 0;
        if(lane_number==initial_lane_number) { //Same lane
                if(loc>initial_loc) { //Final location bigger than initial
                  for(int i = initial_loc+1; i<loc; i++){
                    if(parking[lane_number*locations+i]!="__"){ //Check if blocked for that location
                      if(loc==locations-1){ //If location is final one, check the other way
                        for(int j = initial_loc-1; j>-1; j--){
                          if(parking[lane_number*locations+j]!="__"){
                              return 5;
                            }
                        }
                        return 4;
                      }
                        return 5;
                      }
                    }
                    return 1; //Possible grid -> forward in same lane
                  }
                else if(loc<initial_loc){
                  for(int i = initial_loc-1; i>loc; i--){
                    if(parking[lane_number*locations+i]!="__"){
                      if(loc==0){
                        for(int j = initial_loc+1; j<locations; j++){
                          if(parking[lane_number*locations+j]!="__"){
                            return 5;
                          }
                        }
                        return 3;
                      }
                        return 5;
                      }
                  }
                  return 2; //Possible grid -> backwards in same lane
                }
        }
        else{
          //Check if a final position on its line can be reached
          for(int i = initial_loc+1; i<locations; i++){
            if (parking[initial_lane_number*locations+i]!="__"){
              checker = 1; //Set one if it is blocked by this side
            }
          }
          for(int i = initial_loc-1; i>-1; i--){
            if (parking[initial_lane_number*locations+i]!="__"){
              if(checker==1){ //If blocked by one side and also blocked for this, set checker equal two
                checker=2;
              }
            }
          }
          if(checker==2){ //If blocked by two sides, no possible grid
            return 5;
          }
          else{
            if(loc==0) { //Possible grid -> first position of another lane
                    return 3;
            }
            else if(loc==locations-1) { //Possible grid -> last position of another lane
                    return 4;
            }
          }
        }
        return 5;
}


vector <string> astar(vector <string> init_parking_mat, vector <string> goal_parking_mat, int lane_number, int locations){

        //struct vector <<closedvec> > closed_set;
        int finalcost = 0;
        vector <string> solution_gscore;
        vector <openvec> open_set;
        vector <openvec> closed_set;
        vector <string> path;
        open_set.push_back(openvec());
        open_set[0].grid = init_parking_mat;
        open_set[0].id = 0;
        int hscore = 0; //Heuristic of the node
        int id_counter = 0; //Number of ids generated by the algorithm
        int loops = 0;

        for (int i = 0; i < lane_number; i++) {
          for (int j = 0; j < locations; j++) {
            hscore += heuristic(init_parking_mat, goal_parking_mat, lane_number, locations, init_parking_mat[i*locations+j]);
          }
        }

        open_set[0].hscore = hscore;
        open_set[0].gscore = 0;
        open_set[0].fscore = open_set[0].hscore + open_set[0].gscore;
        open_set[0].parent_node = -1;
        open_set[0].parent = false;

         while(!open_set.empty()){
           openvec current_vec;

           int minimum = open_set[0].fscore; //Minimum fscore found -> Initialized with first value of open_set
           //Here we look in the open_set list to find the grid with minimum fcost
           for (int i = 0; i < open_set.size(); i++) {
               if(open_set[i].fscore<=minimum){
                 current_vec.id = open_set[i].id;
                 current_vec.fscore = open_set[i].fscore;
                 minimum = current_vec.fscore;
                 current_vec.hscore = open_set[i].hscore;
                 current_vec.gscore = open_set[i].gscore;
                 current_vec.grid = open_set[i].grid;
                 current_vec.parent_node = open_set[i].parent_node;
                 current_vec.parent = open_set[i].parent;
               }
             }


             if(current_vec.hscore == 0){
               finalcost = current_vec.fscore;
               while(current_vec.parent_node!=0){
                 for (int i = 0; i < lane_number; i++) {
                   for(int j = 0; j < locations; j++){
                     path.push_back(current_vec.grid[i*locations+j]);
                   }
                 }
                 for(int i = 0; i < closed_set.size(); i++){
                   if(current_vec.parent_node==closed_set[i].id){
                     solution_gscore.push_back(to_string(current_vec.gscore));
                     current_vec = closed_set[i];
                   }
                 }
               }
               for (int i = 0; i < lane_number; i++) {
                 for(int j = 0; j < locations; j++){
                   path.push_back(current_vec.grid[i*locations+j]);
                 }
               }
               path.push_back(to_string(id_counter));
               path.push_back(to_string(finalcost));
               for(int i = 0; i < solution_gscore.size(); i++){
                 path.push_back(solution_gscore[i]);
               }
               path.push_back(to_string(solution_gscore.size()));
               return path;
             }

           for(int i = 0; i<open_set.size(); i++){
             if(open_set[i].id==current_vec.id){
               open_set.erase(open_set.begin()+i);
             }
           }

           closed_set.push_back(current_vec);

           //Now we have the node with minimum cost
           vector <openvec> decendents;
           struct openvec node;

           for(int i = 0; i<lane_number; i++){
             for(int j = 0; j<locations; j++){
               for(int k = 0; k<lane_number; k++){
                 for(int l = 0; l<locations; l++){
                   if(current_vec.grid[i*locations+j]!="__" && current_vec.grid[k*locations+l]=="__"){
                     if(cost(current_vec.grid, k, l, i, j, locations)!=5){
                       node.id = id_counter++;
                       node.gscore = cost(current_vec.grid, k, l, i, j, locations) + current_vec.gscore;
                       int auxscore = 0;
                       node.grid = current_vec.grid;
                       node.grid[k*locations+l]=node.grid[i*locations+j];
                       node.grid[i*locations+j]="__";
                       for (int x = 0; x < lane_number; x++) {
                         for (int y = 0; y < locations; y++) {
                           if(node.grid[x*locations+y]!="__"){
                           auxscore += heuristic(node.grid, goal_parking_mat, lane_number, locations, node.grid[x*locations+y]);
                          }
                         }
                       }
                       node.parent_node = current_vec.id;
                       node.hscore = auxscore;
                       node.fscore = node.hscore + node.gscore;
                       node.parent = true;
                       decendents.push_back(node);
                     }
                   }
                 }
               }
             }
           }

           for (int i = 0; i < decendents.size(); i++) {
             int global_check = 0;
            for(int j = 0; j<closed_set.size(); j++){
              int repeate_check = 0;
              for(int k = 0; k < lane_number; k++){
                for(int l = 0; l < locations; l++){
                  if(decendents[i].grid[k*locations+l]!=closed_set[j].grid[k*locations+l]){
                    repeate_check++;
                  }
                }
              }
              if(repeate_check!=0){
                global_check++;
              }
            }
            if(global_check==closed_set.size()){
              open_set.push_back(decendents[i]);
            }
           }
       }
       return path;
}

int main(int argc, char const *argv[]) {

        auto t1 = clk::now();
        int number_steps;
        int counter = 0;
        vector<string> initialcars;
        string aux;

        //This part gets all strings from the initial state file
        ifstream initialfile(argv[1]);
        while (!initialfile.eof()) {
                initialfile >> aux;
                initialcars.push_back(aux);
        }
        initialfile.close();

        //Here we erase the last element of the vector, repeated due to the reading algorithm
        initialcars.pop_back();

        int lane_number = stoi(initialcars[0]);
        int locations = stoi(initialcars[1]);

        initialcars.erase(initialcars.begin());
        initialcars.erase(initialcars.begin());

        vector <string> init_parking_mat;

        for (int i = 0; i < lane_number; i++) {
                for (int j = 0; j < locations; j++) {
                        init_parking_mat.push_back(initialcars[0]);
                        initialcars.erase(initialcars.begin());
                }
        }

        //Here, we get the data from the goal file

        vector<string> goalcars;

        ifstream goalfile(argv[2]);
        while (!goalfile.eof()) {
                goalfile >> aux;
                goalcars.push_back(aux);
        }
        goalfile.close();

        //Here we erase the last element of the vector, repeated due to the reading algorithm
        goalcars.pop_back();

        lane_number = stoi(goalcars[0]);
        locations = stoi(goalcars[1]);

        goalcars.erase(goalcars.begin());
        goalcars.erase(goalcars.begin());

        vector<string> goal_parking_mat;

        for (int i = 0; i < lane_number; i++) {
                for (int j = 0; j < locations; j++) {
                        goal_parking_mat.push_back(goalcars[0]);
                        goalcars.erase(goalcars.begin());
                }
        }

        for (int i = 0; i < lane_number; i++) {
                for (int j = 0; j < locations; j++) {
                        if(init_parking_mat[i*locations+j]=="__") {
                        }
                        else{
                                counter++;
                        }
                }
        }

        if (counter==(lane_number*locations)) {
                cout << "Configuration unfeasible. No free slots." << endl;
                return 0;
        }
        vector <string> path;
        path = astar(init_parking_mat, goal_parking_mat, lane_number, locations);
        vector <int> gscores;
        int sol_gscore_size = stoi(path[path.size()-1]);
        path.erase(path.begin()+path.size()-1);
        for(int i = 0; i < sol_gscore_size; i++){
          gscores.push_back(stoi(path[path.size()-1]));
          path.erase(path.begin()+path.size()-1);
        }
        int totalcost = stoi(path[path.size()-1]);
        path.erase(path.begin()+path.size()-1);
        int expansions = stoi(path[path.size()-1]);
        path.erase(path.begin()+path.size()-1);

        cout << endl;
        cout << "CONGRATULATIONS, FINAL CONFIGURATION FOUND!" << endl;
        cout << "The path is:" << endl;

        cout << endl;

        cout << "The goal is:" << endl;

        cout << endl;

        int printcounter = 0;

        while (printcounter<path.size()) {
          cout << path[printcounter] << " ";
          printcounter++;
          if((printcounter%locations)==0){
            cout << endl;
          }
          if((printcounter%(locations*lane_number))==0){
            cout << endl;
          }
        }

        number_steps=path.size()/(locations*lane_number);

        cout << endl;

        cout << "The initial is:" << endl;

        cout << endl;

        for(int i = 0; i < lane_number; i++){
          for(int j = 0; j < locations; j++){
            cout << init_parking_mat[i*locations+j] << " ";
          }
          cout << endl;
        }

        ofstream plan;
        plan.open("plan.plan");

        vector <string> vec_1;
        vector <string> vec_2;

        for(int i = 0; i < sol_gscore_size; i++){
          if(i==0){
            plan << i+1 << ", " << gscores[i] << endl;
          }
          else{
            plan << i+1 << ", " << gscores[i]-gscores[i-1] << endl;
          }

        }

        plan.close();

        ofstream information;
        information.open ("information.info");

        information << "Step length: " << number_steps << endl;
        auto t2 = clk::now();
        auto diff = std::chrono::duration_cast<std::chrono::seconds>(t2-t1);
        information << "Running time (seconds): " << diff.count() << endl;
        information << "Total cost: " << totalcost << endl;
        information << "Expansions: " << expansions << endl;

        information.close();


        return 0;
}
